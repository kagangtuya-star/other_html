# UNIX编程·进程与线程

第7、8章，11章，15章

## 第七章 进程的环境

### C语言程序/进程的一生

#### 进程的出生

当程序执行被拉起一个进程时，最先启动的main 函数是如何被调用的？

```c
int main(int argc， char *argv[]);
//argc是命令行参数的数目，argv 是指向参数的各个指针所构成的数组。
//注意，`ISOC`和`POSIX`都要求`argv[argc]`是一个空指针
```

当内核执行C程序时，在调用main 前先调用一个特殊的**启动例程（主要是个exit函数）**,可执行程序文件将此启动例程指定为程序的起始地址（这是由连接编辑器设置的，而连接编辑器则由 C 编译器调用），启动例程从内核取得命令行参数和环境变量值，然后为按上述方式调用main函数做好安排。

补充，这个例程是这样写的（其实它是用汇编写的，毕竟在main执行之前）：从main函数返回后立即调用exit函数，形式为**`exec(main(argc,argv))`。**这个在后面一章讲的更清楚些。

#### 进程的终止

之后是关于进程的终止，有 8 种方式使得进程终止，其中 5 种为正常终止，3 种异常终止：

- 正常终止方式：
  - 从`main`函数返回
  - 调用`exit`函数
  - 调用`_exit`函数或者`_Exit`函数
  - 多线程的程序中，最后一个线程从其启动例程返回
  - 多线程的程序中，从最后一个线程调用`pthread_exit`函数
- 异常终止方式：
  - 调用`abort`函数
  - 接收到一个信号
  - 多线程的程序中，最后一个线程对取消请求作出响应

`exit/_Exit/_exit`函数三者用于自然正常终止一个程序，如下

```c
// stdlib.h库里
void exit(int status);
void _Exit(int status);
// unistd.h库里
void _exit(int status);
// 它们是不同的标准实现的，所以头文件不一样
```

其中的status整型参数指的是终止状态，`_exit`和`_Exit`函数是立刻进入内核，`exit`函数还要执行一些清理处理，再返回内核。这些终止状态如下：

- 若调用上述三个函数时不带终止状态，则该进程的终止状态是未定义的
- 若`main`执行了一个无返回值的`return`语句，则该进程的终止状态是未定义的
- 若`main`没有声明返回类型为整型，则该进程的终止状态是未定义的
- 若`main`声明返回类型为整型，并且`main`执行到最后一条语句时返回（隐式返回），则该进程的终止状态是 0。
- **`main`函数返回一个整型值与用该值调用`exit`是等价的。即`main`函数中，`exit(100);`等价于`return 100;`**
- 在LINUX中，退出状态码最高是255，一般自定义的代码值为0~255，如果超出255，**则返回该数值除以256的余数**。

之后说一下`exit`函数的清理函数`atexit`，为`int atexit(void (*func) (void));`

`*func`是个函数指针，执行一个函数的返回值`void`，成功返回0，失败返回非0。

一个进程可以登记最多 32 个函数，这些函数将由`exit`函数自动调用，这些函数称作终止处理程序（`atexit`函数就是登记它的）。需要注意的是，`exit`调用这些终止处理程序的顺序与登记它们的时候顺序相反，以及一个此类函数被登记多次，它也会被调用多次。

#### C程序的启动与终止小总结

- `exit`函数首先调用各终止处理程序。

- 内核执行程序的唯一方法是调用一个`exec`函数。

- 内核自愿终止的唯一方法是显式或者隐式（通过调用`exit`函数）的调用`_exit`或者`_Exit`，另外还有强制或者异常中止的方法，可以通过返回值来判断中止的类型。

  ![image-20230701202605861](UNIX编程·进程与线程.assets/image-20230701202605861.png)

### 环境表与环境变量

![](UNIX编程·进程与线程.assets/image-20230701203527387.png)

每个程序都会接收一张环境表，与参数数组一样，这也是一个字符指针数组，其中的每个指针指向一个**以null结束**的 C 字符串，这些字符串称之为环境字符串。

全局变量`envrion`包含了该指针数组的地址：`extern char **envrion`。我们称`environ`为环境指针，它位于头文件`unistd.h`中。

**环境字符串**由`name=value`这种格式的字符串组成。UNIX内核并不查看这些字符串，这些字符串的具体意义由各应用程序解释。

属于是环境变量的体现了↑下面就说环境变量

获取环境变量的值可以用`getenv`函数，`char *getenv(const char*name);`

`name`是环境变量的名字，调用成功返回与`name`关联的环境字符串`value`的指针，失败返回null。

设置环境变量的值可以用这几个函数

```
// include <stdlib.h>
int putenv(char *str);
// 直接设置形式为name=value的字符串，将其放置到进程的环境表中。如果`name`已经存在，则覆盖（非常底层的操作），成功返回0，失败返回非0。

int setenv(const char *name,const char *value,int rewrite);
// 参数依次为环境变量名、环境变量值、指定覆写行为（若为0则如果name在环境表中已存在，则直接返回而不修改；若不为0，直接将其覆写），成功返回0，失败返回-1。

int unsetenv(const char *name);
// 参数为环境变量名，unsetenv是从环境表中删除name的定义，成功返回0，失败返回-1。
```

它们的操作过程如下：

如果修改一个现有的`name`：

- 如果新的`value`长度少于或等于现有`value`的长度，则只需要将新字符串复制到原字符串所用的空间即可
- 如果新的`value`长度大于现有`value`的长度，则必须调用`malloc`为新字符串分配空间，然后将新字符串复制到该空间，接着使环境表中对`name`的指针指向新分配区并释放旧分配区。

如果增加一个新的`name`：

- 如果这是第一次增加一个新的`name`：
- - 则必须调用`malloc`为新指针表分配空间
  - 然后将原来的环境表复制到新分配区
  - 并将新的`name=value`字符串的指针存放到该指针表的表尾，
  - 然后将一个空指针存放在其后
  - 然后使`environ`指向新指针表
  - 最后释放旧的指针表
- 如果这不是第一次增加一个新的`name`，则可知以前已经调用了`malloc`：
- - 则只需要调用`realloc`，以分配比原空间多存放一个指针的空间
  - 并将新的`name=value`字符串的指针存放到该指针表的表尾，
  - 然后将一个空指针存放在其后。

如果删除一个`name`：则只需要先在环境表中找到该指针，然后将所有的后续指针都向环境表的首部依次顺序移动一个位置即可。

malloc下面说。

### C程序的存储空间布局与存储空间分配

![image-20230701210449130](UNIX编程·进程与线程.assets/image-20230701210449130.png)

C程序的组成由低地址到高地址如下：

- 正文段：这是由CPU执行的机器指令部分。
  - 通常正文段是可以共享的。一个程序的可以同时执行N次，但是该程序的正文段在内存中只需要有一份而不是N份
  - 通常正文段是只读的，以防止程序由于意外而修改其指令
- 初始化数据段：通常将它称作数据段。如`int a=1;`
  - 它包含了程序中明确地赋了初值的变量：包括函数外的赋初值的全局变量、函数内的赋初值的静态变量
- 未初始化数据段：通常将它称作bss段。在程序开始执行之前，内核将此段中的数据初始化为0或者空指针。如`int b[100];`
  - 它包含了程序中未赋初值的变量：包括函数外的未赋初值的全局变量、函数内的未赋初值的静态变量。
- 堆段：通常在堆中进行动态存储分配。
  - 由于历史习惯，堆位于未初始化数据段和栈段之间。
- 栈段：临时变量以及每次函数调用时所需要保存的信息都存放在此段中。
  - 每次函数调用时，函数返回地址以及调用者的环境信息（如某些CPU 寄存器的值）都存放在栈中
  - 最新的正被执行的函数，在栈上为其临时变量分配存储空间。

另外，用于动态分布存储空间的函数为`malloc/calloc/realloc`函数，它们成功返回非空指针，失败返回null。

```
#include<stdlib.h>
void *malloc(size_t size);
// 参数为动态分配的存储空间的大小（字节数）
void *calloc(size_t nobj,size_t size);
// 参数为动态分配的对象的数量、每个对象的大小（字节数）
void *realloc(void *ptr,size_t newsize);
// 参数ptr为由malloc或realloc返回的指针，指向一个动态分配的空间；newsize是调整后的动态空间大小（字节数）。注意，如果ptr是`NULL，则realloc与malloc功能相同，即为分配一个指定长度为newsize字节的动态存储空间。
```

这三个分配函数所返回的指针一定是适当对齐的，使其可以用于任何数据对象。

这些分配函数通常使用`sbrk`系统调用实现。该系统调用用于扩充或者缩小进程的堆空间，大多数实现所分配的存储空间要比所要求的稍大一些，额外的空间用来记录管理信息，比如分配块的长度、指向下一个分配块的指针等等。**因此在一个动态分配区的尾部之后或者在起始位置之前写操作会修改另一块的管理记录信息是灾难性的错误，但是由于这种错误不会立即暴露出来，因此很难被发现。**

`realloc`可以增加、减少之前分配的动态存储区长度。对于增加动态存储区的情况，如果在原来动态存储区位置后面有足够的空间可以扩充，则可以在原存储区位置上向高地址扩充，无需移动任何原先的内容，并返回与传给它相同的指针值；如果在原来动态存储区位置后面没有足够的空间可以扩充，则`realloc`分配另一个足够大的动态存储区，然后将原先的内容移动到新的存储区。然后释放原存储区，返回新分配存储区的指针。

最后，这三个函数返回的动态分配区必须用`free()`函数进行释放。如果一个进程调用了`malloc`函数但是没有调用`free`函数，则该进程占用的存储空间就会连续增加，这就是**内存泄漏。**内存泄漏会导致进程地址空间长度慢慢增加直到不再有空闲空间，此时过度的换页开销会导致性能下降。

不过，对一块动态分配的内存，只能`free`一次。如果`free`多次则会发生错误。

### 论`setjmp` 和 `longjmp`函数——跨函数跳转，超越`goto`

在C语言中， `goto`语句是不能够跨越函数的。如果想执行跨函数跳转功能，则使用`setjmp`和`longjmp`，它们称作非局部`goto`。

```
#include<setjmp.h>
int setjmp(jmp_buf env);
void longjmp(jmp_buf env,int val);
```

`setjmp`函数：`env`是一个特殊类型`jmp_buf`，它是某种形式的数组，其内容由`setjmp`函数填写，它必须和配对的`longjmp`使用通过一个`env`。`jmp_buf`类型就是某种形式的数组，其中存放的是在调用`longjmp`时能用来恢复栈状态的所有信息，简单地说，`env`参数就是在`setjmp`和`longjmp`之间传递状态信息。

`longjmp`函数：`env`就是与其相对应的`setjmp`所设置的`env`。它就像是一个传送锚点，从而跳到哪个位置，`val`用于标识本次`longjmp`。因此一个`setjmp`可有多个`longjmp`对应，这些`jmp`之间可以用`val`分辨，`setjmp`就知道是从哪个`longjmp`跳转过来的。

`longjmp`的`val`参数就是`setjmp`的返回值，但是`setjmp`的返回值不一定是`longjmp`的`val`参数。

具体来说，`setjmp()` 用于保存当前执行环境的状态，将这个状态存储到一个特殊类型的数组 `jmp_buf` 中，并返回 0。`longjmp()` 用于恢复之前保存的执行环境的状态，跳转到 `setjmp()` 调用的地方并继续执行，同时传递一个值作为 `setjmp()` 的返回值。

`jmp_buf` 类型实际上就是一个数组，在 `setjmp()` 中，将当前的程序状态保存到这个数组中，以便在后续调用 `longjmp()` 时能够恢复程序状态并跳转到指定位置继续执行。`val` 参数是 `longjmp()` 调用时传递的一个值，用于标识本次 `longjmp()` 调用的原因，可以在 `setjmp()` 中根据这个值进行特定的处理。

### 进程资源限制查询和修改——`getrlimit/setrlimit`函数

```
#include<sys/resource.h>
int getrlimit(int resource,struct rlimit *rlptr);
int setrlimit(int resource,struct rlimit *rlptr);
```

进程的资源限制可用这组函数修改。

这组函数中，`resource`指定资源，`rlptr`指向结构体`struct rlimit`的指针。在`getrlimit`中，它返回资源限制值；在`setrlimit`中，它存放待设置的资源限制值。调用成功返回0，失败返回非0。

```
struct rlimit{
	rlim_t rlim_cur; //软限制：当前的限制值
	rlim_t rlim_max; //硬限制：最大值
};
```

常量`RLIM_INFINITY`指定了一个无限量的限制。

资源限制会由子进程继承。

`resource`可以取下列的常量值之一：

- `RLIMIT_AS`：进程总的可用存储空间的最大长度（字节）。这会影响到`sbrk`函数和`mmap`函数
- `RLIMIT_CORE`：`core`文件的最大字节数。如果为0，则阻止创建`core`文件
- `RLIMIT_CPU`：CPU时间的最大量值（秒），如果超过此软限制时，向该进程发送`SIGXCPU`信号
- `RLIMIT_DATA`：数据段的最大字节长度（包括初始化数据、非初始以及堆的总和）
- `RLIMIT_FSIZE`：可以创建的文件的最大字节长度。当超过此软限制时，向该进程发送`SIGXFSX`信号
- `RLIMIT_MEMLOCK`：一个进程使用`mlock`能够锁定在存储空间中的最大字节长度
- `RLIMIT_MSGQUEUE`：进程为`POSIX`消息队列可分配的最大存储字节数
- `RLIMIT_NICE`：为了影响进程的调度优先级，`nice`值可设置的最大限制
- `RLIMIT_NOFILE`：每个进程能打开的最多文件数。更改此限制将影响到`sysconf`函数在参数`_SC_OPEN_MAX`中返回的值
- `RLIMIT_NPROC`：每个实际用户`ID`可以拥有的最大子进程数。更改此限制将影响到`sysconf`函数在参数`_SC_CHILD_MAX`中返回的值
- `RLIMIT_RSS`：最大驻内存集字节长度
- `RLIMIT_SIGPENDING`：一个进程可排队的信号的最大数量。这个限制是`sigqueue`函数实施的
- `RLIMIT_STACK`：栈的最大字节长度

在更改资源限制时，有三条规则：

- 任何进程都可将一个软限制值更改为小于或者等于其硬限制值
- 任何进程都可以降低其硬限制值，但是它必须大于或者等于其软限制值。**这种降低，对普通用户而言不可逆，因为普通用户不可提高其硬限制值**

- 只有超级用户进程才能够提高其硬限制值。

## 第八章 进程的控制
